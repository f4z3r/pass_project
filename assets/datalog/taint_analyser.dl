// A taint analyser

.type label
.type var
.number_type num

// --> inputs <--

// Assign output of `source()` to variable `x` at label `l`
.decl source(label: label, var: var)
// Call `sink()` with `x` as argument at label `l`
.decl sink(label: label, var:var)
// Label `l1` follows label `l2`
.decl follows(after: label, before: label)
// If condition condition involving `var1` and `var2` at label `l1` holds then label `l2`
// follows label `l1`
.decl if(label: label, jump: label, var1: var, var2: var)
// Join labels `l2` and `l3` at `l1`
.decl join(label: label, join1: label, join2: label)
// Assign the variable/constant `y` to `x` at label `l`
.decl assign(label: label, receiver: var, var1: var, var2: var)

// --> facts <--

.input source
.input sink
.input follows
.input if
.input join
.input assign

// --> analysis <--

// ========================================
// PROGRAM FLOW
// ========================================
// `label` is the first label
.decl first(label: label)
first(L) :- follows(_, L), C = count: {follows(L, _)}, C = 0.

// `label` is the last label
.decl last(label: label)
last(L) :- follows(L, _), C = count: {path(L, _)}, C = 0.

// there is at least one path between `from` and `to` in the control flow.
.decl path(from: label, to: label)
path(F, T) :- follows(T, F).
path(F, T) :- path(F, T1), follows(T, T1).

// `label` is between `from` and `to` (exclusive on both ends).
.decl btw(label: label, from: label, to: label)
btw(L, F, T) :- path(F, L), path(L, T).

// there is a line between `from` and `to` in the program flow. Note that where conditions are checked, the statement
// counts as part of the line. This is a linear unit of program flow.
.decl line(from: label, to: label)
line(F, T) :- path(F, T), if(F, _, _, _), !join_btw(F, T1), !if_btw(F, T1), join(T1, _, _), follows(T1, T).
line(F, T) :- path(F, T), join(F, _, _), !join_btw(F, T1), !if_btw(F, T1), join(T1, _, _), follows(T1, T).
line(F, T) :- path(F, T), join(F, _, _), !join_btw(F, T1), !if_btw(F, T1), if(T1, _, _, _), follows(T1, T).
line(F, T) :- path(F, T), if(F, _, _, _), !join_btw(F, T1), !if_btw(F, T1), if(T1, _, _, _), follows(T1, T).
// Declare the last line as a line as well
line(F, T) :- last(T), join(F, _, _), !join_btw(F, T), !if_btw(F, T), !join(T, _, _).
line(T, T) :- last(T), join(T, _, _).
// Line if no control flow in program
line(F, T) :- last(T), first(F), !if_btw(F, T), !join_btw(F, T), !if(F, _, _, _), !join(T, _, _).

// A full branch in an if statement. Can have sub branches.
.decl branch(from: label, to:label)
branch(F, T) :- path(F, T), if(F, _, _, _), !join_btw(F, T1), !if_btw(F, T1), join(T1, _, _), follows(T1, T).
branch(F, T) :- line(F, T1), branch(F1, T2), line(F2, T),
                follows(F1, T1),
                follows(F2, T2), join(F2, _, _).
branch(F, T) :- branch(F1, T2), line(F2, T),
                follows(F1, F), if(F, _, _, _),
                follows(F2, T2), join(F2, _, _).
branch(F, T) :- line(F, T1), branch(F1, T),
                follows(F1, T1),
                follows(L1, T), join(L1, _, _),
                follows(L2, L1), join(L2, _, _).
branch(F, T) :- branch(F1, T1),
                follows(F1, F), if(F, _, _, _),
                follows(T, T1), join(T, _, _),
                follows(L1, T), join(L1, _, _).
// Add the entire program as a branch
branch(F, T) :- path(F, T), first(F), last(T).

// the parent branch of a given branch.
.decl parent_b(from: label, to: label, P_f: label, p_t: label)
parent_b(F, T, PF, PT) :- branch(F, T), branch(PF, PT), line(FL, PT), follows(FL, T).
parent_b(F, T, PF, PT) :- branch(F, T), branch(PF, PT), path(PF, F), follows(PT, T).
// program it its own parent
parent_b(F, T, F, T) :- first(F), last(T).

// `var` is used in condition at label `entry`
.decl in_cond(var: var, entry: label)
in_cond(X, E) :- if(E, _, X, _).
in_cond(X, E) :- if(E, _, _, X).

// `label` is in branch from `from` to `to`
.decl in_brch(label: label, from: label, to: label)
in_brch(L, F, T) :- branch(F, T), path(F, L), path(L, T).
in_brch(F, F, T) :- branch(F, T).
in_brch(T, F, T) :- branch(F, T).

// ========================================
// CHANGES
// ========================================
// variable `var` changed at label `label`.
.decl chgd(label: label, var: var)
chgd(L, X) :- assign(L, X, _, _).
chgd(L, X) :- source(L, X).

// a `join` statement occurs between `from` and `to`.
.decl join_btw(from: label, to: label)
join_btw(F, T) :- join(L, _, _), btw(L, F, T).

// a `if` statement occurs between `from` and `to`.
.decl if_btw(from: label, to: label)
if_btw(F, T) :- if(L, _, _, _), btw(L, F, T).

// ========================================
// DEPENDENCE
// ========================================
// `dependent` is dependent on `on` due to operation at label `op`
.decl dpnd(label: label, dependent: var, on: var, op: label)
// Explicit dependence on assignment
dpnd(L, X, Y, O) :- x_dpnd(L, X, Y, O).
// Implicit dependence in branch.
dpnd(L, X, Y, E) :- m_dpnd(L, X, Y, E).
// Dependence carries over as long as no reassignment occurs.
dpnd(L, X, Y, O) :- dpnd(L1, X, Y, O), follows(L, L1), !chgd(L, X).

// Implicit dependence
.decl m_dpnd(label: label, dependent: var, on: var, entry: label)
m_dpnd(L, X, Y, E) :- branch(E, T), in_cond(Y, E), assign(L, X, _, _), btw(L, E, T1), follows(T1, T).

// Explicit dependence
.decl x_dpnd(label: label, dependent: var, on: var, op: label)
x_dpnd(O, X, Y, O) :- assign(O, X, Y, _).
x_dpnd(O, X, Y, O) :- assign(O, X, _, Y).

// ========================================
// TAINTED VARIABLES
// ========================================
// `var` is tainted at label `label` due to dependency on `dep` at `origin`.
.decl tntd(label: label, var: var, dep: var, origin: label)
tntd(O, X, X, O) :- source(O, X).
// Taint carries over as long as the variable does not change
tntd(L, X, Y, O) :- tntd(L1, X, Y, O), follows(L, L1), !chgd(L, X).
// Tainted variables affect their dependents
tntd(L, X, Z, O) :- tntd(L, Y, Z, _), dpnd(L, X, Y, O).

// `dependent` is tainted at the end of line between `from` and `to` due to dependency on `on`
.decl tntd_line(dependent: var, on: var, from: label, to: label)
tntd_line(X, Y, F, T) :- line(F, T), tntd(T, X, Y, _).

// `dependent` is tainted at the end of branch between `from` and `to` due to dependency on `on`. Note that this is
// only the case if all subbranches are also tainted.
.decl tntd_brch(dependent: var, on: var, from: label, to: label)
tntd_brch(X, Y, F, T) :- tntd_line(X, Y, F, T), !last(T).
tntd_brch(X, Y, F, T) :- tntd_line(X, Y, F, T), last(T), first(F).
tntd_brch(X, Y, F, T) :- branch(F, T), line(F1, T), join(F1, L1, L2), tntd_brch(X, Y, _, L1), tntd_brch(X, Y, _, L2).

// `var` requires sinking
.decl req_sink(var: var)
req_sink(X) :- sink(_, X).

// ========================================
// SANITATION
// ========================================
/*
 * Potential sanitation locations:
 * ===============================
 * - if not in a branch:
 *   + on a join.
 *   + after sourcing or assignement
 * - if in a branch:
 *   + on a join
 *   + after sourcing or assignement
 *   + before sourcing or assignement
 *   + before branch split
 *
 *
 * if not on a branch:
 * ===================
 * Sanitise only if NO subpath between potential sourcing and sink detaints the variable. If this is the case, sanitise
 * at the source/assignment if possible (i.e. the variable was sourced/assigned to before branching and NOT
 * reassigned in ANY sub-branch). Else sanitise at last join (this is guaranteed to be before a all sinks).
 *
 * if in branch:
 * =============
 * Sanitise only on join if ALL subpaths require sanitation and some "sister" branch does not require sanitation.
 * Otherwise sanitation after the sourcing/assignment.
 *
 * The only case where in branch should be sanitised before assignment or before a branch split is when the assigned
 * variable is dependent on some tainted variable that does not require sanitation based on "sister" branches.
 *
 *
 *
 * SANITATION RULES
 * ================
 * The only reason to sanitise a variable that is not sourced explicitly is that it depends on two sourced variables
 * that will not be sunk and that no other variable dependends on.
 *
 * 1. Check if a variable requires sanitation (aka there is a sink at the end of the program and the variable is
 *    still tainted at that point).
 * 2. If the it dependent on two tainted variables, check if there is another variable that dependends on.
 *    - if not, saninitse this variable as low as possible, all paths leading to that point are tainted.
 *    - if yes, sanitise the two dependencies as high as possible, all paths from there on keep the taint.
 */

// branch requiring sanitation. This is the outermost tainted branch for variable `dependent` dependent on `on`.
.decl sani_brch(dependent: var, on: var, from: label, to: label)
sani_brch(X, Y, F, T) :- tntd_brch(X, Y, F, T), parent_b(F, T, PF, PT), !tntd_brch(X, Y, PF, PT).
// Account for fact that if the tntd_brch is the whole program, then that needs to be output
sani_brch(X, Y, F, T) :- tntd_brch(X, Y, F, T), first(F), last(T).

/*
 * Sanitise after entrance of branch or after source (whichever is last) if less then 2 dependencies that do not
 * require sanitation (i.e. are not sunk).
 *
 * Sanitise after join or before sink (whichever is first) if 2 or more dependencies that do not require sanitation
 * (i.e. are not sunk).
 */
// `var` needs sanitation at label `label
.decl rule_1(var: var, label: label)
// Sanitise after source if less than 2 dependencies and entire program (if source is not right before fork).
rule_1(X, L) :- sink(_, Y), sani_brch(Y, X, F, T),
                !at_least_2_dependencies(Y, F, T),
                first(F), last(T),
                source(S, X), follows(L, S), !more_than_1_follower(S).
.decl rule_1_1(var: var, label: label)
// Sanitise after source if less than 2 dependencies and entire program (if source is right before fork).
rule_1_1(Y, L) :- sink(L, Y), sani_brch(Y, _, F, T),
                  !at_least_2_dependencies(Y, F, T),
                  first(F), last(T),
                  source(S, X), more_than_1_follower(S).
.decl rule_2(var: var, label: label)
// Sanitise after entrance of branch if less than 2 dependencies and not entire program.
rule_2(X, L) :- sink(_, Y), sani_brch(Y, X, F, T),
                !m_dpnd(_, Y, X, F),
                !at_least_2_dependencies(Y, F, T),
                !first(F), !last(T),
                follows(L, F),
                tntd(T, Y, X, O), in_brch(O, F, T). // If operation is in the branch
.decl rule_2_1(var: var, label: label)
// Sanitise after entrance of branch if less than 2 dependencies and not entire program.
rule_2_1(Y, L) :- sink(_, Y), sani_brch(Y, X, F, T),
                  !m_dpnd(_, Y, X, F),
                  !at_least_2_dependencies(Y, F, T),
                  !first(F), !last(T),
                  follows(L, F),
                  tntd(T, Y, X, O), !in_brch(O, F, T). // If operation is NOT in the branch
.decl rule_3(var: var, label: label)
// Sanitise after assignment if less than 2 dependencies, not entire program and the dependency is implicit.
rule_3(Y, L) :- sink(_, Y), sani_brch(Y, X, F, T),
                m_dpnd(L1, Y, X, F),
                !at_least_2_dependencies(Y, F, T),
                !first(F), !last(T),
                follows(L, L1).

.decl rule_4(var: var, label: label)
// Sanitise before sink if 2 or more dependencies and entire program.
rule_4(X, S) :- sink(S, X), sani_brch(X, Y, F, T),
                at_least_2_dependencies(X, F, T),
                first(F), last(T).
.decl rule_5(var: var, label: label)
// Sanitise after join if 2 or more dependencies and not entire program.
rule_5(X, L) :- sink(_, X), sani_brch(X, Y, F, T),
                at_least_2_dependencies(X, F, T),
                !first(F), !last(T),
                follows(L, T).


// === === === === === === === === === === ===
// Backup, fails test 4 from first 7.
// === === === === === === === === === === ===
// .decl rule_1(var: var, label: label)
// // Sanitise after source if less than 2 dependencies and entire program.
// rule_1(X, L) :- sink(_, Y), sani_brch(Y, X, F, T),
//                 !at_least_2_dependencies(Y, F, T),
//                 first(F), last(T),
//                 source(S, X), follows(L, S).
// .decl rule_2(var: var, label: label)
// // Sanitise after entrance of branch if less than 2 dependencies and not entire program.
// rule_2(X, L) :- sink(_, Y), sani_brch(Y, X, F, T),
//                 !m_dpnd(_, Y, X, F),
//                 !at_least_2_dependencies(Y, F, T),
//                 !first(F), !last(T),
//                 follows(L, F).
// .decl rule_3(var: var, label: label)
// // Sanitise after assignment if less than 2 dependencies, not entire program and the dependency is implicit.
// rule_3(Y, L) :- sink(_, Y), sani_brch(Y, X, F, T),
//                 m_dpnd(L1, Y, X, F),
//                 !at_least_2_dependencies(Y, F, T),
//                 !first(F), !last(T),
//                 follows(L, L1).

// .decl rule_4(var: var, label: label)
// // Sanitise before sink if 2 or more dependencies and entire program.
// rule_4(X, S) :- sink(S, X), sani_brch(X, Y, F, T),
//                 at_least_2_dependencies(X, F, T),
//                 first(F), last(T).
// .decl rule_5(var: var, label: label)
// // Sanitise after join if 2 or more dependencies and not entire program.
// rule_5(X, L) :- sink(_, X), sani_brch(X, Y, F, T),
//                 at_least_2_dependencies(X, F, T),
//                 !first(F), !last(T),
//                 follows(L, T).

.decl at_least_2_dependencies(var: var, from: label, to: label)
at_least_2_dependencies(X, F, T) :- sani_brch(X, Z, F, T), !req_sink(Z),
                                    sani_brch(X, W, F, T), !req_sink(W), W != Z.

.decl more_than_1_follower(label: label)
more_than_1_follower(L) :- follows(L1, L), follows(L2, L), L1 != L2.

// `var` needs sanitation at label `label
.decl sanitise(var: var, label: label)
sanitise(X, L) :- rule_1(X, L).
sanitise(X, L) :- rule_1_1(X, L).
sanitise(X, L) :- rule_2(X, L).
sanitise(X, L) :- rule_2_1(X, L).
sanitise(X, L) :- rule_3(X, L).
sanitise(X, L) :- rule_4(X, L).
sanitise(X, L) :- rule_5(X, L).

.output sanitise
.output req_sink
.output branch
.output parent_b
.output line
.output tntd_brch
.output line
.output tntd_line
.output sani_brch
.output dpnd
.output tntd
.output rule_1
.output rule_1_1
.output rule_2
.output rule_2_1
.output rule_3
.output rule_4
.output rule_5



// .decl test(var: var, label: label, num: num)
// test(X, S, C) :- sink(S, X), sani_brch(X, Y, F, T),
//               C = count: {sani_brch(X, Z, F, T), !req_sink(Z)}, C > -10.

// .output test
