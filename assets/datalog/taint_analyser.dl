// A taint analyser.

.type label
.number_type const
.type var

// -- inputs --

// Assign output of `source()` to variable `x` at label `l`
.decl source(label: label, var: var)
// Call `sink()` with `x` as argument at label `l`
.decl sink(label: label, var:var)
// Label `l1` follows label `l2`
.decl follows(after: label, before: label)
// If condition condition involving `var1` and `var2` at label `l1` holds then label `l2`
// follows label `l1`
.decl if(label: label, jump: label, var1: var, var2: var)
// Join labels `l2` and `l3` at `l1`
.decl join(label: label, join1: label, join2: label)
// Apply `op()` to variables `y` and `z` and store the result in `x` at label `l`
.decl opv(label: label, receiver: var, var1: var, var2: var)
// Apply `op()` to variable `y` and constant `c` and store the result in `x` at label `l`
.decl opc(label: label, receiver: var, var: var, const: const)
// Assign the variable/constant `y` to `x` at label `l`
.decl assign(label: label, receiver: var, var: var)


// -- facts --
.input source
.input sink
.input follows
.input if
.input join
.input opv
.input opc
.input assign

// -- analysis --

// ========================================
// PROGRAM FLOW
// ========================================
// `after` occurs after `before` in the control flow.
.decl after(after: label, before: label)
after(L1, L2) :- follows(L1, L2).
after(L1, L2) :- after(L1, L3), follows(L3, L2).

// variable `var` changed at label `label`.
.decl changed(label: label, var: var)
changed(L, X) :- assign(L, X, _).
changed(L, X) :- source(L, X).
changed(L, X) :- opv(L, X, _, _).
changed(L, X) :- opc(L, X, _, _).

// variable `var` changed between labels `label1` and `label2`.
.decl changed_btw(var: var, label1: label, label2: label)
changed_btw(X, L1, L2) :- changed(L3, X), after(L3, L1), after(L2, L3).
changed_btw(X, L1, L2) :- changed(L2, X), after(L2, L1).

// variable `var` was sourced between labels `label1` and `label2`.
.decl sourced_btw(var: var, label1: label, label2: label)
sourced_btw(X, L1, L2) :- source(L3, X), after(L3, L1), after(L2, L3).
sourced_btw(X, L1, L2) :- source(L2, X), after(L2, L1).

// at label `label`, `target` is where the last change to `var` occured.
.decl last_chg(label: label, var: var, target: label)
last_chg(L, X, T) :- changed(T, X), !changed_btw(X, T, L), after(L, T).

// at label `label`, `target` is where the last source to `var` occured.
.decl last_src(label: label, var: var, target: label)
last_src(L, X, T) :- source(T, X), !sourced_btw(X, T, L), after(L, T).

// label `label` is in an if statement between label `entry` and label `join`
.decl in_if(label: label, entry: label, join: label)
in_if(L, E, J) :- if(E, _, _, _), join(J, E, _), after(L, E), after(J, L).
in_if(L, E, J) :- if(E, _, _, _), join(J, _, E), after(L, E), after(J, L).

// `var` was changed at label `label` in if with entry at label `label`
.decl changed_in_if(var: var, label: label, entry: label)
changed_in_if(X, L, E) :- assign(L, X, Y), in_if(L, E, _).
changed_in_if(X, L, E) :- opv(L, X, Y, _), in_if(L, E, _).
changed_in_if(X, L, E) :- opv(L, X, _, Y), in_if(L, E, _).
changed_in_if(X, L, E) :- opc(L, X, Y, _), in_if(L, E, _).

// `var` was used in condition of if at label `entry`
.decl in_condition(var: var, entry: label)
in_condition(X, E) :- if(E, _, X, _).
in_condition(X, E) :- if(E, _, _, X).

// ========================================
// TAINTED VARIABLES
// ========================================
// `var` is tainted at label `l`
.decl tainted(label: label, var: var)
tainted(L, X) :- source(L, X).
tainted(L, X) :- tainted(L1, X), !changed_btw(X, L1, L), after(L, L1).
tainted(L, X) :- expl_depend(L, X, Y), tainted(L, Y), !sanitised(L, Y).
tainted(L, X) :- impl_depend(L, X, Y), tainted(L, Y), !sanitised(L, Y).

.decl sanitised(label: label, var: var)
sanitised(L, X) :- sink(L1, X), after(L, L1), !sourced_btw(X, L1, L).


// ========================================
// EXPLICIT DEPENDENCE
// ========================================
// `x` is explicitly dependent on `y`
.decl expl_depend(label: label, dependent: var, on: var)
// Transitivity
expl_depend(L, X, Z) :- expl_depend(L, X, Y), expl_depend(L, Y, Z).
// Explicit dependence on operations
expl_depend(L, X, Y) :- opc(L, X, Y, _).
expl_depend(L, X, Y) :- opv(L, X, Y, _).
expl_depend(L, X, Y) :- opv(L, X, _, Y).
// Explicit dependence on assignment
expl_depend(L, X, Y) :- assign(L, X, Y).

// Dependence carries over as long as it does not change
expl_depend(L, X, Y) :- expl_depend(L1, X, Y), after(L, L1), !changed_btw(X, L1, L).

// ========================================
// IMPLICIT DEPENDENCE
// ========================================
.decl impl_depend(label: label, dependent: var, on: var)
impl_depend(L, X, Y) :- changed_in_if(X, L, E), in_condition(Y, E).
// Transitivity
impl_depend(L, X, Z) :- impl_depend(L, X, Y), impl_depend(L, Y, Z).
// Dependence carries over as long as it does not change
impl_depend(L, X, Y) :- impl_depend(L1, X, Y), after(L, L1), !changed_btw(X, L1, L).



// ========================================
// RESULT
// ========================================
.decl res(label: label, var: var)
res(L, X) :- sink(L, X), tainted(L, X), !sanitised(L, X).

.output res


