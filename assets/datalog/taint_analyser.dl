// A taint analyser

.type label
.type var
.number_type const
.number_type num

// -- inputs --

// Assign output of `source()` to variable `x` at label `l`
.decl source(label: label, var: var)
// Call `sink()` with `x` as argument at label `l`
.decl sink(label: label, var:var)
// Label `l1` follows label `l2`
.decl follows(after: label, before: label)
// If condition condition involving `var1` and `var2` at label `l1` holds then label `l2`
// follows label `l1`
.decl if(label: label, jump: label, var1: var, var2: var)
// Join labels `l2` and `l3` at `l1`
.decl join(label: label, join1: label, join2: label)
// Apply `op()` to variables `y` and `z` and store the result in `x` at label `l`
.decl opv(label: label, receiver: var, var1: var, var2: var)
// Apply `op()` to variable `y` and constant `c` and store the result in `x` at label `l`
.decl opc(label: label, receiver: var, var: var, const: const)
// Assign the variable/constant `y` to `x` at label `l`
.decl assign(label: label, receiver: var, var: var)


// -- facts --
.input source
.input sink
.input follows
.input if
.input join
.input opv
.input opc
.input assign

// -- analysis --

// ========================================
// PROGRAM FLOW
// ========================================
// `after` occurs after `before` in the control flow.
.decl after(after: label, before: label)
after(L1, L2) :- follows(L1, L2).
after(L1, L2) :- after(L1, L3), follows(L3, L2).

// variable `var` changed at label `label`.
.decl changed(label: label, var: var)
changed(L, X) :- assign(L, X, _).
changed(L, X) :- source(L, X).
changed(L, X) :- opv(L, X, _, _).
changed(L, X) :- opc(L, X, _, _).

// `label` is between `from` and `to`
.decl between(label: label, from: label, to: label)
between(L, F, T) :- after(L, F), after(T, L).

// variable `var` changed between labels `label1` and `label2`.
.decl changed_btw(var: var, label1: label, label2: label)
changed_btw(X, L1, L2) :- changed(L3, X), between(L3, L1, L2).
changed_btw(X, L1, L2) :- changed(L2, X), after(L2, L1).

// variable `var` was sourced between labels `label1` and `label2`.
.decl sourced_btw(var: var, label1: label, label2: label)
sourced_btw(X, L1, L2) :- source(L3, X), between(L3, L1, L2).
sourced_btw(X, L1, L2) :- source(L2, X), after(L2, L1).

// variable `var` was assigned to between labels `label1` and `label2`.
.decl assigned_btw(var: var, label1: label, label2: label)
assigned_btw(X, L1, L2) :- assign(L3, X, _), between(L3, L1, L2).
assigned_btw(X, L1, L2) :- assign(L2, X, _), after(L2, L1).

// variable `var` was sunk between labels `label1` and `label2`.
.decl sunk_btw(var: var, label1: label, label2: label)
sunk_btw(X, L1, L2) :- sink(L3, X), between(L3, L1, L2).
sunk_btw(X, L1, L2) :- sink(L2, X), after(L2, L1).

// at label `label`, `target` is where the last change to `var` occured.
.decl last_chg(label: label, var: var, target: label)
last_chg(L, X, T) :- changed(T, X), !changed_btw(X, T, L), after(L, T).

// at label `label`, `target` is where the last source to `var` occured.
.decl last_src(label: label, var: var, target: label)
last_src(L, X, T) :- source(T, X), !sourced_btw(X, T, L), after(L, T).

// label `label` is in an if statement between label `entry` and label `join`
.decl in_if_rng(label: label, entry: label, join: label)
in_if_rng(L, E, J) :- if(E, _, _, _), join(J, E, _), between(L, E, J).
in_if_rng(L, E, J) :- if(E, _, _, _), join(J, _, E), between(L, E, J).

// label `label` is in any if statement
.decl in_if(label: label)
in_if(L) :- in_if_rng(L, _, _).

// `var` was changed at label `label` in if with entry at label `label`
.decl changed_in_if(var: var, label: label, entry: label)
changed_in_if(X, L, E) :- assign(L, X, _), in_if_rng(L, E, _).
changed_in_if(X, L, E) :- opv(L, X, _, _), in_if_rng(L, E, _).
changed_in_if(X, L, E) :- opc(L, X, _, _), in_if_rng(L, E, _).

// `var` was used in condition of if at label `entry`
.decl in_condition(var: var, entry: label)
in_condition(X, E) :- if(E, _, X, _).
in_condition(X, E) :- if(E, _, _, X).

// ========================================
// EXPLICIT DEPENDENCE
// ========================================
// `dependent` is explicitly dependent on `on` due to operation at label `op`
.decl expl_depend(label: label, dependent: var, on: var, op: label)
// Explicit dependence on operations
expl_depend(L1, X, Y, L) :- opc(L, X, Y, _), follows(L1, L).
expl_depend(L1, X, Y, L) :- opv(L, X, Y, _), follows(L1, L).
expl_depend(L1, X, Y, L) :- opv(L, X, _, Y), follows(L1, L).
// Explicit dependence on assignment
expl_depend(L1, X, Y, L) :- assign(L, X, Y), follows(L1, L).

// Dependence carries over as long as it does not change
expl_depend(L1, X, Y, L) :- expl_depend(L2, X, Y, L), after(L1, L2), !changed_btw(X, L2, L1).

// ========================================
// IMPLICIT DEPENDENCE
// ========================================
// `dependent` is implicitly dependent on `on` due to condition at `cond`
.decl impl_depend(label: label, dependent: var, on: var, cond: label)
impl_depend(L, X, Y, E) :- changed_in_if(X, L, E), in_condition(Y, E).
// Dependence carries over as long as it does not change
impl_depend(L, X, Y, E) :- impl_depend(L1, X, Y, E), after(L, L1), !changed_btw(X, L1, L).

.decl impl_dep_btw(dependent: var, on: var, from: label, to: label)
impl_dep_btw(X, Y, F, T) :- impl_depend(L1, X, Y, _), between(L1, F, T).
impl_dep_btw(X, Y, F, T) :- impl_depend(L1, X, Y, _), after(T, F).


// ========================================
// TAINTED VARIABLES
// ========================================
// `var` is tainted at label `l`
.decl tainted(label: label, var: var)
tainted(L, X) :- source(L1, X), follows(L, L1).
tainted(L, X) :- tainted(L1, X), !changed_btw(X, L1, L), after(L, L1).
tainted(L, X) :- expl_depend(L, X, Y, L1), tainted(L1, Y).
tainted(L, X) :- impl_depend(L, X, Y, _), tainted(L, Y).

.decl sanitised(label: label, var: var)
sanitised(L, X) :- sink(L1, X), after(L, L1), !sourced_btw(X, L1, L).
sanitised(L, X) :- expl_depend(L, Y, X, _).

// `var` requires sanitation between labels `from` to label `to`
.decl req_san(var: var, from: label, to: label)
req_san(X, F, T) :- source(F, X), !in_if(F), sink(T, X), after(T, F), !changed_btw(X, F, T), !sunk_btw(X, F, T1), follows(T, T1).
req_san(X, F, T) :- tainted(F, Y), !sanitised(F, Y), expl_depend(_, X, Y, F), sink(T, X), after(T, F), !changed_btw(X, F, T), !impl_dep_btw(X, _, F, T).

// `var` requires sanitation at label`at`
.decl req_san_at(var: var, at: label)
req_san_at(X, L) :- req_san(X, F, T), between(L, F, T).

// `var` being sunk at `label` is dependent on `num` variables that need to be also sanitised
.decl dep_san(label: label, var: var, num: num)
dep_san(L, X, C) :- req_san(X, _, L), C = count: {expl_depend(L, X, Y, L1), req_san(Y, F, T), between(L1, F, T), !impl_depend(L, X, Y, _)}.
// ========================================
// RESULT
// ========================================
.decl no_dep(var: var, label:label)
no_dep(X, L) :- req_san(X, F, L), dep_san(L, X, C), C < 1, FC = count: {follows(_, F)}, FC > 1.
no_dep(X, F) :- req_san(X, F1, L), dep_san(L, X, C), C < 1, FC = count: {follows(_, F1)}, FC < 2, follows(F, F1).

.decl dep_in_if(var: var, label:label)
dep_in_if(X, T) :- tainted(F, Y), !sanitised(F, Y), impl_depend(L1, X, Y, F), sink(T, X), after(T, F), !changed_btw(X, L1, T).
dep_in_if(X, T) :- source(F, X), in_if(F), sink(T, X), after(T, F), !changed_btw(X, F, T), !sunk_btw(X, F, T1), follows(T, T1).


.decl have_dep(var: var, label:label)
have_dep(X, O) :- tainted(O, X), !sanitised(O, X), expl_depend(T, Y, X, O), req_san(Y, _, T), !req_san_at(X, O), X != Y, dep_san(T, Y, C), C > 0.

.decl res(var: var, label: label)
res(X, L) :- no_dep(X, L).
res(X, L) :- dep_in_if(X, L).
res(X, L) :- have_dep(X, L).


.output res

// .decl test(label: label, var: var, dep: var, entry:label)
// test(L, X, Y, L1) :- impl_depend(L, X, Y, L1), tainted(L1, Y).

// .output test
